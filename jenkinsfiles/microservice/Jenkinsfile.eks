// Leave blank
def taggedImageLatest = ''
def taggedImageCommitHash = ''
def serviceName = ''

pipeline {
  agent any

  tools {
    maven 'Maven 3.8.4'
  }

  stages {
    stage('Clone') {
      steps {
        checkout scm
        script {
          serviceName = getServiceName(env.GIT_URL)
          updateService(serviceName)
        }
      }
    }

    stage('Test') {
      steps {
        sh 'mvn clean install test'
      }
    }

    stage('SonarQube Code Analysis') {
      steps {
        withSonarQubeEnv('dw-sonarqube') {
          sh 'mvn verify sonar:sonar -Dmaven.test.skip=true'
        }
      }
    }

    stage('Quality Gate') {
      steps {
        timeout(time: 5, unit: 'MINUTES') {
          waitForQualityGate abortPipeline: true
        }
      }
    }

    stage('Package Maven Project') {
      steps {
        sh 'mvn package -Dmaven.test.skip=true'
      }
    }

    stage('Build Docker Image') {
      environment {
        COMMIT_HASH = "`git log -1 --pretty=format:\"%h\"`"
      }

      steps {
        script {
          def ecrRepository = "dw-${serviceName}-microservice"
          def ecrUrl = getAwsConfig()['ecrUrl']

          taggedImageLatest = "${ecrUrl}/${ecrRepository}"
          taggedImageCommitHash = "${ecrUrl}/${ecrRepository}:${COMMIT_HASH}"

          sh "docker build -t ${taggedImageLatest} ."
          sh "docker tag ${taggedImageLatest} ${taggedImageCommitHash}"
        }
      }
    }

    stage('Push Image') {
      steps {
        withCredentials([
        [
          $class: 'AmazonWebServicesCredentialsBinding',
          credentialsId: 'DW-Jenkins-AWS-Credentials',
          accessKeyVariable: 'AWS_ACCESS_KEY_ID',
          secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
        ]
      ])
        {
          script {
            def config = getAwsConfig()
            def ecrUrl = config['ecrUrl']
            def eksRegion = config['region']
            sh "aws ecr get-login-password --region ${eksRegion}| docker login --username AWS --password-stdin ${ecrUrl}"
            sh "docker push ${taggedImageCommitHash}"
            sh "docker push ${taggedImageLatest}"
          }
        }
      }
    }

    stage('Deploy EKS Service') {
      steps {
        script {
          def clusterName = getAwsConfig()['kubernetesClusterName']

          if (clusterExists(clusterName)) {
            updateService(serviceName)
            return
          }

          createCluster(clusterName)
        }
      }
    }
  }

  post {
    always {
      sh 'mvn clean'
      sh 'docker system prune -f'
    }
  }
}

def getAwsConfig() {
  withCredentials([[
    $class: 'AmazonWebServicesCredentialsBinding',
    credentialsId: 'DW-Jenkins-AWS-Credentials',
    accessKeyVariable: 'AWS_ACCESS_KEY_ID',
    secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']])
  {
    def configIdCmd = $/
    aws secretsmanager list-secrets --output table \
    | grep Name \
    | grep -oE "dw-infra-secret-\w+"/$

    def configId = bash(configIdCmd)
    def configJsonText = bash($/aws secretsmanager get-secret-value --secret-id ${configId}/$)
    def configJson = readJSON text: configJsonText
    def secretStringJson = readJSON text: configJson['SecretString']

    return secretStringJson
  }
}

// Extracts the service name from the git url
// It should return bank, underwriter, user or transaction
def getServiceName(gitRepositoryUrl) {
  def serviceName = (gitRepositoryUrl =~ /^.*aline-(.+?)-microservice.*/)[0][1]
  checkServiceName(serviceName)

  return serviceName
}

def checkServiceName(serviceName) {
  def acceptable = ['bank', 'underwriter', 'user', 'transaction']

  if (acceptable.contains(serviceName) == false) {
    error "Invalid service name: '${serviceName}'"
  }
}

def clusterExists(clusterName) {
  throwIfNull(clusterName, 'clusterName')

  try {
    def region = getAwsConfig()['region']

    def cmd = $/
    aws eks list-clusters --region ${region} --output table \
    | grep -oE '\${clusterName}\b'/$

    def clusterMatch = bash(cmd)

    return clusterMatch != null && clusterMatch?.isAllWhitespace() == false
  }
  catch (Exception ex) {
    echo 'Error looking for cluster. Returning false'
    return false
  }
}

def updateService(serviceName) {
  throwIfNull(serviceName, 'serviceName')

  withCredentials([[
    $class: 'AmazonWebServicesCredentialsBinding',
    credentialsId: 'DW-Jenkins-AWS-Credentials',
    accessKeyVariable: 'AWS_ACCESS_KEY_ID',
    secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']])
  {
    def config = getAwsConfig()
    def devopsDir = 'devops'
    def repoUrl = config['devopsRepoUrl']
    def kubernetesPath = config['kubernetesEksPath']
    def clusterName = config['kubernetesClusterName']
    def region = config['region']

    // TODO Remove branch
    sh "rm -rf ${devopsDir} && git clone -b eks-deployment ${repoUrl} ${devopsDir}"

    dir("${devopsDir}/${kubernetesPath}") {
      try { sh 'rm ~/.kube/config' } catch (Exception ex) { }
      def clusterContextCmd = $/
      aws eks --region ${region} update-kubeconfig --name ${clusterName} \
      | grep -oP '\barn.+?cluster/.+?\b'/$

      bash(clusterContextCmd)
      sh 'chmod 700 ~/.kube/config'

      try {
        sh "make upgrade_${serviceName}"
      }
      catch (Exception ex) {
        sh "make install_${serviceName}"
      }
    }
  }
}

def createCluster(clusterName) {
  throwIfNull(clusterName, 'clusterName')

  withCredentials([[
    $class: 'AmazonWebServicesCredentialsBinding',
    credentialsId: 'DW-Jenkins-AWS-Credentials',
    accessKeyVariable: 'AWS_ACCESS_KEY_ID',
    secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']])
  {
    def config = getAwsConfig()
    def bucketName = getBucketName(config['bucketPrefix'])
    def devopsDir = 'devops'
    def repoUrl = config['devopsRepoUrl']
    def eksPath = config['eksctlPath']
    def kubernetesPath = config['kubernetesEksPath']

    // TODO Remove branch
    sh "rm -rf ${devopsDir} && git clone -b eks-deployment ${repoUrl} ${devopsDir}"

    dir("${devopsDir}/${eksPath}") {
      sh "aws s3 cp s3://${bucketName}/${eksctlS3EnvPath} .env"
      try { sh 'make lbInit' } catch (Exception ex) { }
      sh 'make init'
    }

    dir("${devopsDir}/${kubernetesPath}") {
      sh 'kubectl apply -R -f eks-config'
      sh 'make install'
    }
  }
}

def getBucketName(bucketPrefix) {
  return bash($/aws s3 ls | grep -oP '\b${s3BucketPrefix}\d+\b'/$)
}

// Pipes act weird in jenkins so use eval to make sure it completes properly
def bash(script) {
  throwIfNull(script, 'script')

  return sh(script: $/eval ${script}/$, returnStdout: true).trim()
}

def throwIfNull(value, name) {
  if (value == null) {
    error "${name} is null"
  }
}
